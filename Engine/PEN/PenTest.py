import numpy as np
from scipy.signal import sosfiltfilt, butter

from matplotlib import pyplot as plt
from datetime import datetime

from Pen import *
from Data import *
from Plot import *

def main():

    #-------- Testing Data pipeline -----------

    database = Data();    
    symbols = ['ETH/USDT'] #['BNB/USDT'] #['XRP/USDT', 'ETH/USDT', 'XRP/USDT', 'BNB/USDT'] #, 'XRP/USDT'] #, 'BNB/USDT' ]

   
    #---------------------------------------------- Golobals ---------------------------------

    #relative, focus, length, changePast, y0, ymax, left, right, cnt_refine = True, 40000, 60*24, 0.001, 1, 500, -3, 6, 1
    #relative, focus, length, changePast, y0, ymax, left, right, cnt_refine = True, 40000, 60*3, 0.0005, 1, 500, -3, 6, 1
    #relative, focus, length, changePast, y0, ymax, left, right, cnt_refine = True, 10110, 60*3, 0.001, 1, 400, -3, 6, 1
    logPrice, maxPastNodes, padding, relative, focus, length, future, changePast, y0, ymax, left, right, cnt_refine = True, 150, True, True, 72110, 60*168, 60*3, 0.000100, 1, 1200, -1, 6, 1
    cntPredict, cntLabels, changeFuture = 2, 2, 0.007 #
    future_offset = 1 # The distance between focus, which belongs to the past, and the first point in the future. 1 means no skip.
    wn_past, wn_future = 0.5, 0.25

    penPast = Pen( y0 = y0, len_x = length, ymax = ymax, left = left, right = right, relative = relative )
    penFuture = Pen( y0 = 1, len_x = future, ymax = 1, left = left, right = right, relative = relative )

    #------------------------------------------------ Plot modules ---------------------------

    fig, axes = plt.subplots( nrows = len(symbols), ncols = 1, figsize = (16, 3 * len(symbols) + 4) )
    if len(symbols) == 1 : axes = [axes]

    plt.subplots_adjust( hspace = 0 )
 
    def ChartSymbol( symbol, prices_past, ranges_past, nodes_past, prices_future, ranges_future, nodes_future, prices_concat, joint_nodes, change, axes, xticks = None, indetail = False ):
        total_c, node_c, width = 'maroon', 'green', 1.0

        label = symbol + (' log ' if logPrice else ' ') + 'price'
        axes.set_ylabel(label)
        if xticks is None: axes.set_xticks( [] )

        axes.axvline( x = 0, color = 'black', linestyle = "--", label = 'Current time and price. The lasest past point.', linewidth = 0.8 * width )

        #------------ concat
        axes.plot( np.array(range(len(prices_concat)))-length+1, np.flip(prices_concat), marker = '', linestyle = '--', color = 'red', linewidth = width, label = 'Raw price data, not smoothed.')

        #------------ future
        xoff = len(prices_past)+len(prices_future)-len(prices_concat)-1 # This is actually eqaul to -future_offset, but this module should't know that variable.
        axes.plot( np.array(range(len(prices_future)))-xoff, np.flip(prices_future), marker = '', linestyle = '--', color = 'navy', label = 'Future prices, smoothened.', linewidth = width)
        axes.plot( len(prices_future)-np.flip(nodes_future)-xoff-1, np.flip(prices_future[nodes_future]), marker = 'o', color = 'cyan', label = '{:d} Points changing over {:.1f}% in {:d} minutes'.format(cntPredict, changeFuture*100, future), linewidth = width * 2 )
        for idx in range(len(nodes_future)):
            x = len(prices_future)-np.flip(nodes_future[idx])-xoff-1; axes.plot( [x, x], ranges_future[idx], color = 'cyan', linewidth = 0.7 * width )

        #------------ past
        xoff = length-len(prices_past)
        axes.plot( -np.flip(np.array(range(len(prices_past))))-xoff, np.flip(prices_past), marker = '', linestyle = '--', color = 'navy', label = 'Past prices, smoothened', linewidth = width )
        #if indetail:

        axes.plot( -np.flip(nodes_past)-xoff, np.flip(prices_past[nodes_past]), marker = '', linestyle = '--', color = 'maroon', label = '{:d} key points over past {:d} minutes'.format(maxPastNodes, length), linewidth = 0.5 * width )
        axes.plot( -np.flip(joint_nodes)-xoff, np.flip(prices_past[joint_nodes]), marker = '', color = 'darkgreen', label = "Past key points starting from {:.1f}m%".format(change*1000*100), linewidth = width )
        for idx in range(len(nodes_past)):
            x = -np.flip(nodes_past[idx])-xoff; axes.plot( [x, x], ranges_past[idx], color = 'darkgreen', linewidth = 0.7 * width )


        if indetail:
            for x in joint_nodes: axes.axvline( x = -x-xoff, color = 'maroon', linestyle = "--", linewidth = 0.8 )
            for x in nodes_past: axes.axvline( x = -x-xoff, color = 'darkgreen', linestyle = "--", linewidth = 0.8 )

        axes.legend()

        return
  

    #------------------------------------------ Testing routine -----------------------------------

    def NormalizePrice( prices, filter = False, order = 2, Wn = 0.5 ):
        prices = np.log10( prices )
        if filter:
            sos = butter(order, Wn, output='sos')
            prices = sosfiltfilt(sos, prices)
        return prices


    arr_indis_past = None; list_nodes_past = []; arr_ranges_past = None
    arr_indis_future = None; list_nodes_future = []; arr_ranges_future = None
    arr_indis_concat = None
    curtime = None
    for symbol in symbols:
        data = database.PrepareData( symbol )
        if curtime is None: curtime = data['datesTrain'][focus]

        # The index of data is in the opposite direction of time. idxTimeward = False.

        #==================== Future
        prices_future = data['closesTrain'][focus-future-(future_offset-1) : focus-(future_offset-1)] #------------------------------------------------------------
        if logPrice: prices_future = NormalizePrice(prices_future, filter = True, order = 1, Wn = wn_future)
        if arr_indis_future is None: arr_indis_future = np.zeros((0, future), dtype = prices_future.dtype)

        prices_future = np.flip( prices_future )
        nodes_future = penFuture.GetNodes( prices_future, start = 0, maxNodes = cntPredict, padding = False, change = changeFuture, toggle = True, idxTimeward = True )
        prices_future = np.flip( prices_future ); nodes_future = len(prices_future) - nodes_future - 1

        arr_indis_future = np.append( arr_indis_future, np.expand_dims(prices_future, axis=0), axis = 0 )
        list_nodes_future.append( nodes_future )

        if arr_ranges_future is None: arr_ranges_future = np.zeros((0, len(nodes_future), 2), dtype = prices_future.dtype)
        ranges_future = penFuture.GetRanges( prices_future, nodes_future, changeFuture )
        arr_ranges_future = np.append( arr_ranges_future, np.expand_dims(ranges_future, axis=0), axis=0 )

        #==================== Past
        prices_past = data['closesTrain'][focus:focus+length]
        if logPrice: prices_past = NormalizePrice(prices_past, filter = True, order = 1, Wn = wn_past)
        if arr_indis_past is None: arr_indis_past = np.zeros((0, length), dtype = prices_past.dtype)
        nodes_past = penPast.GetNodes( prices_past, takeZero = True, start = 0, maxNodes = maxPastNodes, padding = padding, change = changePast, toggle = True, idxTimeward = False )
        arr_indis_past = np.append( arr_indis_past, np.expand_dims(prices_past, axis=0), axis = 0 )
        list_nodes_past.append( nodes_past )

        if arr_ranges_past is None: arr_ranges_past = np.zeros((0, len(nodes_past), 2), dtype = prices_past.dtype)
        ranges_past = penPast.GetRanges( prices_past, nodes_past, changePast )
        arr_ranges_past = np.append( arr_ranges_past, np.expand_dims(ranges_past, axis=0), axis=0 )

        #===================== Concat
        if arr_indis_concat is None: arr_indis_concat = np.zeros((0, length+future+(future_offset-1)), dtype = prices_past.dtype)
        prices_concat = data['closesTrain'][focus-future-(future_offset-1) : focus+length]
        if logPrice: prices_concat = NormalizePrice(prices_concat, filter = False)
        arr_indis_concat = np.append( arr_indis_concat, np.expand_dims(prices_concat, axis=0), axis = 0 )

    """
    min_node = future - 1
    for nodes in list_nodes_future:
        if len(nodes) > cntLabels-1 and min_node > nodes[cntLabels-1] : min_node = nodes[cntLabels-1]
    len_future = min_node - int(1.0*min_node/10) - 1
    for idx in range(len(list_nodes_future)):
        list_nodes_future[idx] = [ node for node in list_nodes_future[idx] if node > len_future ]
    arr_indis_future = arr_indis_future[:, len_future : ]
    """

    #joint_nodes = np.array( sorted(list(set(np.concatenate( list_nodes_past, axis = 0 )))) )
    joint_nodes = penPast.JoinAssetsNodes( arr_indis_past, list_nodes_past, maxPastNodes, padding, changePast, cnt_refine, idxTimeward = False )

    sequence = penPast.ConvertToSequence( arr_indis_past, joint_nodes, idxTimeward = False )

    zip_rate = (1.0 - sequence.shape[0] * sequence.shape[1] / arr_indis_past.shape[0] / arr_indis_past.shape[1] ) * 100
    
    for index, symbol in enumerate(symbols):
        xticks = "" if index == len(symbols) - 1 else None
        ChartSymbol( symbol, arr_indis_past[index], arr_ranges_past[index], list_nodes_past[index], arr_indis_future[index], \
            arr_ranges_future[index], list_nodes_future[index], arr_indis_concat[index], joint_nodes, changePast, axes[index], xticks = xticks, indetail = False )

    fig.suptitle( "An observation of \"WHAT PAST GIVES WHAT FUTURE\" is extracted from history, for trainig data. " + datetime.now().strftime('%Y-%m-%d %H:%M:%S') \
        + "\n The ML model will learn to predict the cyan-color points from the darkgreen-color points, i.e. LEARNIG LEAST FROM MOST." \
        + "\n Every past time point gives an example like this. This way, a long past price history is zipped and used to predict the near future." \
        + "\n" + ('Relative, ' if relative else 'Absolute, ') \
        + "changePast: {:.1f}m%, y0: {:d}, ymax: {:d}, left: {:.0f}, right: {:.0f}, focus: {:d}, wn_past: {:.2f}, wn_future: {:.2f}, Zip-rate: {:.0f}%"\
        .format(changePast*1000*100, y0, ymax, left, right, focus, wn_past, wn_future, zip_rate) \
        , fontsize = 11 )
    #plt.title( 'Polynimal Encoders Nested (PEN) demonstrated', fontsize = 14 )
    plt.xlabel( "Minute with origin of '" + str(curtime) + "'")
    #plt.ylabel( 'price' )

    plt.show()


if __name__ == '__main__':
    main() 